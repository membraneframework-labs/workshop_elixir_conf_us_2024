# A: intro

```elixir
Logger.configure(level: :info)

# All necessary dependencies are installed by installing the package below
Mix.install([
  {:workshop_elixir_conf_us_2024, path: Path.join(__DIR__, "../..")}
])
```

## Get node

Value returned by `Node.self()` can be used to get the metrics from the running pipelines.

Go to `livebooks/metrics.livemd` go visualize them.

```elixir
Node.self()
```

## Example

Here we have an example of a Membrane pipeline, that transcodes and transmuxes video from MP4 container with video encoded with H264 codec to MKV container with video encoded with VP9 codec.

```elixir
defmodule TransmuxingPipeline do
  use Membrane.Pipeline

  @impl true
  def handle_init(_ctx, _options) do
    priv = "#{__DIR__}/../../priv/" |> Path.expand()
    mp4_path = Path.join(priv, "fixtures/bunny_without_sound.mp4")
    mkv_path = Path.join(priv, "outputs/bunny_without_sound.mkv")

    spec = [
      child(:source, %Membrane.File.Source{location: mp4_path})
      |> child(:mp4_demuxer, Membrane.MP4.Demuxer.ISOM)
      |> via_out(:output, options: [kind: :video])
      |> child(:h264_parser_1, %Membrane.H264.Parser{output_stream_structure: :annexb})
      |> child(:h264_decoder, Membrane.H264.FFmpeg.Decoder)
      |> child(:vp9_encoder, Membrane.VP9.Encoder)
      |> child(:matroska_muxer, Membrane.Matroska.Muxer)
      |> child(:file_sink, %Membrane.File.Sink{location: mkv_path})
    ]

    {[spec: spec], %{}}
  end

  @impl true
  def handle_element_end_of_stream(:file_sink, _input, _ctx, state) do
    {[terminate: :normal], state}
  end

  @impl true
  def handle_element_end_of_stream(_element, _input, _ctx, state), do: {[], state}
end
```

## Run the Example

Cell below runs the pipeline and waits until it finishes its processing.

```elixir
{:ok, supervisor, _pipeline} = Membrane.Pipeline.start_link(TransmuxingPipeline)
ref = Process.monitor(supervisor)

receive do
  {:DOWN, ^ref, _process, _pid, _reason} -> :ok
end
```

If execution of the cell above takes too long, change the source file name from `bunny_without_sound.mp4` on `bunny_without_sound_short.mp4`. You can do it in the rest of the exercises as well.

If you don't run livebook on your machine, download the result video with this button:

```elixir
Kino.Download.new(fn -> File.read!("#{__DIR__}/../../priv/outputs/bunny_without_sound.mkv") end,
  label: "Download the video",
  filename: "bunny_without_sound.mkv"
)
```

Now, you can run the output file with the following command:

```bash
$ ffplay workshop_elixir_conf_us_2024/priv/outputs/bunny_without_sound.mkv
```

## Exercise A1: Scaling of a video

Add `Membrane.FFmpeg.SWScale.Converter` to the pipeline above and set the video width to 640 pixels. [Documentation](https://hexdocs.pm/membrane_ffmpeg_swscale_plugin/Membrane.FFmpeg.SWScale.Converter.html) might be helpful.

> How long did the pipeline work before adding an element reducing the video size? What is the reason of this change?

## Exercise A2: Add sound

`priv/fixtures/bunny_without_sound.mp4` is an MP4 container having only one video track. `priv/fixtures/bunny_with_sound.mp4` is an MP4 container having two tracks: one audio and one video.

Modify the pipeline in the following way:

* as a source file use `priv/a2/bunny_with_sound.mp4` instead of `priv/a1/bunny_without_sound.mp4`
* save the output of your pipeline in `priv/outputs/bunny_with_sound.mkv`
* modify the children specification returned from the `handle_init/2` callback to support audio track as well, so that the output file contains the audio from the source file.

## Exercise A3*: Revert colors

Write your own element reverting colors and add it to the pipeline. Adding `Membrane.FFmpeg.SWScale.Converter` before and after your custom filter might be helpful. Use the element template below:

```elixir
defmodule ColorReverter do
  use Membrane.Filter
  alias Membrane.RawVideo

  def_input_pad(:input, accepted_format: %RawVideo{pixel_format: :RGB})
  def_output_pad(:output, accepted_format: %RawVideo{pixel_format: :RGB})

  # callbacks implementation
end
```

```elixir
defmodule ColorRevertingPipeline do
  use Membrane.Pipeline

  @impl true
  def handle_init(_ctx, _options) do
    priv = "#{__DIR__}/../../priv/" |> Path.expand()
    mp4_path = Path.join(priv, "fixtures/bunny_with_sound.mp4")
    mkv_path = Path.join(priv, "outputs/bunny_with_reverted_colors.mkv")

    spec = [
      child(:source, %Membrane.File.Source{location: mp4_path})
      |> child(:mp4_demuxer, Membrane.MP4.Demuxer.ISOM)
      |> via_out(:output, options: [kind: :video])
      |> child(:h264_parser_1, %Membrane.H264.Parser{output_stream_structure: :annexb})
      |> child(:h264_decoder, Membrane.H264.FFmpeg.Decoder)
      # |> ...
      |> child(:h264_encoder, %Membrane.H264.FFmpeg.Encoder{preset: :fast})
      |> child(:h264_parser_2, %Membrane.H264.Parser{output_stream_structure: :avc1})
      |> child(:matroska_muxer, Membrane.Matroska.Muxer)
      |> child(:file_sink, %Membrane.File.Sink{location: mkv_path})
    ]

    {[spec: spec], %{}}
  end

  @impl true
  def handle_element_end_of_stream(:file_sink, _input, _ctx, state) do
    {[terminate: :normal], state}
  end

  @impl true
  def handle_element_end_of_stream(_element, _input, _ctx, state), do: {[], state}
end
```

Now run the pipeline:

```elixir
{:ok, supervisor, _pipeline} = Membrane.Pipeline.start_link(ColorRevertingPipeline)
ref = Process.monitor(supervisor)

receive do
  {:DOWN, ^ref, _process, _pid, _reason} -> :ok
end

Kino.Download.new(
  fn -> File.read!("#{__DIR__}/../../priv/outputs/bunny_with_reverted_colors.mkv") end,
  label: "Download the video",
  filename: "bunny_with_reverted_colors.mkv"
)
```

Play the output file with the command below:

```bash
$ ffplay workshop_elixir_conf_us_2024/priv/outputs/bunny_with_reverted_colors.mkv
```
