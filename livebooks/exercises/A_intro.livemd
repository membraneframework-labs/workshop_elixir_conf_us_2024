# A: intro

```elixir
Logger.configure(level: :info)

# All necessary dependencies are installed by installing the package below
Mix.install([
  {:workshop_elixir_conf_us_2024, path: Path.join(__DIR__, "../..")}
])
```

## Setup the Livebook

If you run Livebook locally, get the value of your `PATH` env by running `$ echo $PATH`. Then, go to Livebook `Settings` (from the Livebook home page) and then to `Enviroment variables` and set `PATH` to the value you got from the command line.

## Get node

Value returned by `Node.self()` can be used to get the metrics from the running pipelines.

Go to `livebooks/metrics.livemd` go visualize them.

```elixir
Node.self()
```

## Short introduction and example

* `Pipeline` to elixirowy process, który zawiaduje membranowymi `Elementami`, które zajmują się przetwarzaniem danych multimedialnych
* aby moduł stał sie Pipelinem, trzeba dodać do niego linijke `use Membrane.Pipeline`
* Pipeline'y mogą implementować membranowe callbacki [tutaj wstaw link do callbackow].
* Kazdy callback otrzymuje jako argumenty: 
  * stan pipelineu, ktory mozna modyfikowac (tak jak w GenServerze)
  * context, ktory jest generowany przez framework i zawiera rozne informacji, np o Elementach
  * czasami jeszcze inne argumenty, w zaleznosci od callbacku
* Kazdy callback musi zwrocic dwuelementową tuplę `{actions, state}`, gdzie 
  * `actions` to lista akcji, które wykona framework [link do akcji]
  * `state` to (byc moze zmodyfikowany) stan elementu, ktory zostanie przekazany do nastepnego wywolania jakiegos callbacku
* As we said, `Elements` zajmują się właściwym przetwarzaniem danych
* Aby modul stal sie Elementem, musi `use Membrane.Element`
* Tak jak Pipelines, Elementy mogą implementowac [callbacki], które muszą zwracac tuple `{actions, state}`
* Elementy posiadają output oraz input `pady`.
* Elementy mozna ze sobą linkować, korzystając z padów: Jezeli jakis element posiada output pad, mozna go połączyc z innym elementem, ktory posiada input pad
* Elementy wysylają bufory z danymi na swoje output pady za pomocą akcji. Gdy element wysyla bufor na swoj output pad, to zlinkowany z nim element otrzyma ten bufor z odpowiedniego input padu.
* Elementy mogą posiadać zero, jeden lub wiele input oraz output padow (take a look at the pictures)

Here we have an example of a Membrane pipeline, that transcodes and transmuxes video from MP4 container with video encoded with H264 codec to MKV container with video encoded with VP9 codec.

```elixir
defmodule TransmuxingPipeline do
  use Membrane.Pipeline

  @impl true
  def handle_init(_ctx, _options) do
    priv = "#{__DIR__}/../../priv/" |> Path.expand()
    mp4_path = Path.join(priv, "fixtures/bunny_without_sound.mp4")
    mkv_path = Path.join(priv, "outputs/bunny_without_sound.mkv")

    spec = [
      child(:source, %Membrane.File.Source{location: mp4_path})
      |> child(:mp4_demuxer, Membrane.MP4.Demuxer.ISOM)
      |> via_out(:output, options: [kind: :video])
      |> child(:h264_parser_1, %Membrane.H264.Parser{output_stream_structure: :annexb})
      |> child(:h264_decoder, Membrane.H264.FFmpeg.Decoder)
      |> child(:vp9_encoder, Membrane.VP9.Encoder)
      |> child(:matroska_muxer, Membrane.Matroska.Muxer)
      |> child(:file_sink, %Membrane.File.Sink{location: mkv_path})
    ]

    {[spec: spec], %{}}
  end

  @impl true
  def handle_element_end_of_stream(:file_sink, _input, _ctx, state) do
    {[terminate: :normal], state}
  end

  @impl true
  def handle_element_end_of_stream(_element, _input, _ctx, state), do: {[], state}
end
```

## Run the Example

Cell below runs the pipeline and waits until it finishes its processing.

```elixir
{:ok, supervisor, _pipeline} = Membrane.Pipeline.start_link(TransmuxingPipeline)
ref = Process.monitor(supervisor)

receive do
  {:DOWN, ^ref, _process, _pid, _reason} -> :ok
end
```

If execution of the cell above takes too long, change the source file name from `bunny_without_sound.mp4` on `bunny_without_sound_short.mp4`. You can do it in the rest of the exercises as well.

If you don't run livebook on your machine, download the result video with this button:

```elixir
Kino.Download.new(fn -> File.read!("#{__DIR__}/../../priv/outputs/bunny_without_sound.mkv") end,
  label: "Download the video",
  filename: "bunny_without_sound.mkv"
)
```

Now, you can run the output file with the following command:

```bash
$ ffplay workshop_elixir_conf_us_2024/priv/outputs/bunny_without_sound.mkv
```

## Exercise A1: Scaling of a video

Add `Membrane.FFmpeg.SWScale.Converter` to the pipeline above and set the video width to 640 pixels. [Documentation](https://hexdocs.pm/membrane_ffmpeg_swscale_plugin/Membrane.FFmpeg.SWScale.Converter.html) might be helpful.

> How long did the pipeline work before adding an element reducing the video size? What is the reason of this change?

## Exercise A2: Add sound

`priv/fixtures/bunny_without_sound.mp4` is an MP4 container having only one video track. `priv/fixtures/bunny_with_sound.mp4` is an MP4 container having two tracks: one audio and one video.

Modify the pipeline in the following way:

* as a source file use `priv/fixtures/bunny_with_sound.mp4` instead of `priv/fixtures/bunny_without_sound.mp4`
* save the output of your pipeline in `priv/outputs/bunny_with_sound.mkv`
* modify the children specification returned from the `handle_init/2` callback to support audio track as well, so that the output file contains the audio from the source file.

## Exercise A3*: Revert colors

Write your own element reverting colors and add it to the pipeline. Adding `Membrane.FFmpeg.SWScale.Converter` before and after your custom filter might be helpful. Use the element template below:

```elixir
defmodule ColorReverter do
  use Membrane.Filter
  alias Membrane.RawVideo

  def_input_pad(:input, accepted_format: %RawVideo{pixel_format: :RGB})
  def_output_pad(:output, accepted_format: %RawVideo{pixel_format: :RGB})

  # callbacks implementation
end
```

```elixir
defmodule ColorRevertingPipeline do
  use Membrane.Pipeline

  @impl true
  def handle_init(_ctx, _options) do
    priv = "#{__DIR__}/../../priv/" |> Path.expand()
    mp4_path = Path.join(priv, "fixtures/bunny_with_sound.mp4")
    mkv_path = Path.join(priv, "outputs/bunny_with_reverted_colors.mkv")

    spec = [
      child(:source, %Membrane.File.Source{location: mp4_path})
      |> child(:mp4_demuxer, Membrane.MP4.Demuxer.ISOM)
      |> via_out(:output, options: [kind: :video])
      |> child(:h264_parser_1, %Membrane.H264.Parser{output_stream_structure: :annexb})
      |> child(:h264_decoder, Membrane.H264.FFmpeg.Decoder)
      # |> ...
      |> child(:h264_encoder, %Membrane.H264.FFmpeg.Encoder{preset: :fast})
      |> child(:h264_parser_2, %Membrane.H264.Parser{output_stream_structure: :avc1})
      |> child(:matroska_muxer, Membrane.Matroska.Muxer)
      |> child(:file_sink, %Membrane.File.Sink{location: mkv_path})
    ]

    {[spec: spec], %{}}
  end

  @impl true
  def handle_element_end_of_stream(:file_sink, _input, _ctx, state) do
    {[terminate: :normal], state}
  end

  @impl true
  def handle_element_end_of_stream(_element, _input, _ctx, state), do: {[], state}
end
```

Now run the pipeline:

```elixir
{:ok, supervisor, _pipeline} = Membrane.Pipeline.start_link(ColorRevertingPipeline)
ref = Process.monitor(supervisor)

receive do
  {:DOWN, ^ref, _process, _pid, _reason} -> :ok
end

Kino.Download.new(
  fn -> File.read!("#{__DIR__}/../../priv/outputs/bunny_with_reverted_colors.mkv") end,
  label: "Download the video",
  filename: "bunny_with_reverted_colors.mkv"
)
```

Play the output file with the command below:

```bash
$ ffplay workshop_elixir_conf_us_2024/priv/outputs/bunny_with_reverted_colors.mkv
```
