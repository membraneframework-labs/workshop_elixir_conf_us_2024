<!-- livebook:{"file_entries":[{"name":"demuxer.png","type":"attachment"},{"name":"demuxer_video_only.png","type":"attachment"},{"name":"file.png","type":"attachment"},{"name":"file1.png","type":"attachment"},{"name":"muxer.png","type":"attachment"},{"name":"source.png","type":"attachment"}]} -->

# A: intro

```elixir
Logger.configure(level: :info)

# All necessary dependencies are installed by installing the package below
Mix.install([
  {:workshop_elixir_conf_us_2024, path: Path.join(__DIR__, "../..")}
])
```

## Setup the Livebook

If you run Livebook locally, get the value of your `PATH` env by running `$ echo $PATH`. Then, go to Livebook `Settings` (from the Livebook home page) and then to `Enviroment variables` and set `PATH` to the value you got from the command line.

## Get node

Value returned by `Node.self()` can be used to get the metrics from the running pipelines.

Go to `livebooks/metrics.livemd` to visualize them.

```elixir
Node.self()
```

## Introduction

Pipeline is an Elixir Process that manages [Membrane](https://hexdocs.pm/membrane_core/readme.html) Elements and handles the processing of multimedia data.

To make the module a Pipeline, add the line `use Membrane.Pipeline` to it.

Pipelines implement Membrane [callbacks](https://membrane.stream/learn/get_started_with_membrane/3#callbacks).
Each callback receives the following arguments:

* The pipeline state - which can be modified (as in GenServer).
* The context - which is generated by the framework and contains various information, including about Pipeline's Elements.

Sometimes also some other arguments, depending on the callback.

Each callback must return a two-element tuple `{actions, state}`, where

* `actions` is the list of actions the framework will execute ([docs](https://hexdocs.pm/membrane_core/Membrane.Pipeline.Action.html)).
* `state` is the (possibly modified) state of the element, which will be passed to the next invocation of any callback.

Elements handle the actual data processing.
For a module to become an Element, it must `use` `Membrane.Filter`, `Membrane.Source`, `Membrane.Sink` or `Membrane.Endpoint`.

Just like Pipelines, Elements can implement [callbacks](https://membrane.stream/learn/get_started_with_membrane/3#callbacks), which must return a tuple `{actions, state}`.

Elements have output and input `pads` and can be linked with each other using them: if an element has an output pad, it can be linked with another element that has an input pad.

Elements send buffers with data via output pads using actions. When an element sends a buffer via an output pad, the linked element receives this buffer from the respective input pad.

Elements can have zero, one, or multiple input and output pads (take a look at the pictures below)

Before sending the first data buffer, Elements must send a `stream format` using the `:stream_format` action ([docs](https://hexdocs.pm/membrane_core/Membrane.Element.Action.html#t:stream_format/0)).

`stream format` describes the data that will be contained in the buffers. For example, it may specify that each buffer will contain one RGB video frame with dimensions 1920p x 1080p.

`stream format` must match the `accepted_format` field in the definition of the pad through which it was sent.

<!-- livebook:{"break_markdown":true} -->

![](files/file1.png)

<!-- livebook:{"break_markdown":true} -->

![](files/demuxer_video_only.png)

<!-- livebook:{"break_markdown":true} -->

![](files/demuxer.png)

<!-- livebook:{"break_markdown":true} -->

![](files/muxer.png)

## Example

Here we have an example of a Membrane pipeline that transcodes and transmuxes video from an MP4 container with video encoded with the H264 codec to an MKV container with video encoded with the VP9 codec.

```elixir
defmodule TransmuxingPipeline do
  use Membrane.Pipeline

  @impl true
  def handle_init(_ctx, _options) do
    priv = "#{__DIR__}/../../priv/" |> Path.expand()
    mp4_path = Path.join(priv, "fixtures/bunny_with_sound.mp4")
    mkv_path = Path.join(priv, "outputs/bunny_with_sound.mkv")

    spec = [
      child(:source, %Membrane.File.Source{location: mp4_path})
      |> child(:mp4_demuxer, Membrane.MP4.Demuxer.ISOM)
      |> via_out(:output, options: [kind: :video])
      |> child(:h264_parser_1, %Membrane.H264.Parser{output_stream_structure: :annexb})
      |> child(:h264_decoder, Membrane.H264.FFmpeg.Decoder)
      |> child(:converter, %Membrane.FFmpeg.SWScale.Converter{output_width: 640})
      |> child(:h264_encoder, %Membrane.H264.FFmpeg.Encoder{preset: :fast})
      |> child(:h264_parser_2, %Membrane.H264.Parser{output_stream_structure: :avc1})
      |> child(:matroska_muxer, Membrane.Matroska.Muxer)
      |> child(:file_sink, %Membrane.File.Sink{location: mkv_path}),
      get_child(:mp4_demuxer)
      |> via_out(:output, options: [kind: :audio])
      |> get_child(:matroska_muxer)
    ]

    {[spec: spec], %{}}
  end

  @impl true
  def handle_element_end_of_stream(:file_sink, _input, _ctx, state) do
    {[terminate: :normal], state}
  end

  @impl true
  def handle_element_end_of_stream(_element, _input, _ctx, state), do: {[], state}
end
```

## Run the Example

Cell below runs the pipeline and waits until it finishes its processing.

```elixir
{:ok, supervisor, _pipeline} = Membrane.Pipeline.start_link(TransmuxingPipeline)
ref = Process.monitor(supervisor)

receive do
  {:DOWN, ^ref, _process, _pid, _reason} -> :ok
end
```

If execution of the cell above takes too long, change the source file name from `bunny_without_sound.mp4` on `bunny_without_sound_short.mp4`. You can do it in the rest of the exercises as well.

If you don't run livebook on your machine, download the result video with this button:

```elixir
Kino.Download.new(fn -> File.read!("#{__DIR__}/../../priv/outputs/bunny_without_sound.mkv") end,
  label: "Download the video",
  filename: "bunny_without_sound.mkv"
)
```

Now, you can run the output file with the following command:

```bash
$ ffplay workshop_elixir_conf_us_2024/priv/outputs/bunny_without_sound.mkv
```

## Exercise A1: Scaling of a video

Add `Membrane.FFmpeg.SWScale.Converter` to the pipeline above and set the video width to 640 pixels. [Documentation](https://hexdocs.pm/membrane_ffmpeg_swscale_plugin/Membrane.FFmpeg.SWScale.Converter.html) might be helpful.

> How long did the pipeline work before adding an element reducing the video size? What might be causing it?

## Exercise A2: Add sound

`priv/fixtures/bunny_without_sound.mp4` is an MP4 container that has only one video track. `priv/fixtures/bunny_with_sound.mp4` is an MP4 container that has two tracks: one audio and one video.

Modify the pipeline in the following way:

* use `priv/fixtures/bunny_with_sound.mp4` as a source file instead of `priv/fixtures/bunny_without_sound.mp4`
* save the output of your pipeline in `priv/outputs/bunny_with_sound.mkv`
* modify the children specification returned by the `handle_init/2` callback to support audio track as well, so that the output file contains audio from the source file.

<!-- livebook:{"branch_parent_index":1} -->

## Exercise A3*: Revert colors

Write your own element reverting colors and add it to the pipeline. Adding `Membrane.FFmpeg.SWScale.Converter` before and after your custom filter might be helpful. Use the element template below:

```elixir
defmodule ColorReverter do
  use Membrane.Filter
  alias Membrane.RawVideo

  def_input_pad(:input, accepted_format: %RawVideo{pixel_format: :RGB})
  def_output_pad(:output, accepted_format: %RawVideo{pixel_format: :RGB})

  @impl true
  def handle_buffer(:input, buffer, _ctx, state) do
    payload = for <<byte <- buffer.payload>>, into: <<>>, do: <<255 - byte>>
    buffer = %{buffer | payload: payload}
    {[buffer: {:output, buffer}], state}
  end
end
```

```elixir
defmodule ColorRevertingPipeline do
  use Membrane.Pipeline

  @impl true
  def handle_init(_ctx, _options) do
    priv = "#{__DIR__}/../../priv/" |> Path.expand()
    mp4_path = Path.join(priv, "fixtures/bunny_with_sound.mp4")
    mkv_path = Path.join(priv, "outputs/bunny_with_reverted_colors.mkv")

    spec = [
      child(:source, %Membrane.File.Source{location: mp4_path})
      |> child(:mp4_demuxer, Membrane.MP4.Demuxer.ISOM)
      |> via_out(:output, options: [kind: :video])
      |> child(:h264_parser_1, %Membrane.H264.Parser{output_stream_structure: :annexb})
      |> child(:h264_decoder, Membrane.H264.FFmpeg.Decoder)
      |> child(:rgb_converter, %Membrane.FFmpeg.SWScale.Converter{format: :RGB})
      |> child(:color_reverter, ColorReverter)
      |> child(:yuv_converter, %Membrane.FFmpeg.SWScale.Converter{format: :I420})
      |> child(:h264_encoder, %Membrane.H264.FFmpeg.Encoder{preset: :fast})
      |> child(:h264_parser_2, %Membrane.H264.Parser{output_stream_structure: :avc1})
      |> child(:matroska_muxer, Membrane.Matroska.Muxer)
      |> child(:file_sink, %Membrane.File.Sink{location: mkv_path}),
      get_child(:mp4_demuxer)
      |> via_out(:output, options: [kind: :audio])
      |> get_child(:matroska_muxer)
    ]

    {[spec: spec], %{}}
  end

  @impl true
  def handle_element_end_of_stream(:file_sink, _input, _ctx, state) do
    {[terminate: :normal], state}
  end

  @impl true
  def handle_element_end_of_stream(_element, _input, _ctx, state), do: {[], state}
end
```

Now run the pipeline:

```elixir
{:ok, supervisor, _pipeline} = Membrane.Pipeline.start_link(ColorRevertingPipeline)
ref = Process.monitor(supervisor)

receive do
  {:DOWN, ^ref, _process, _pid, _reason} -> :ok
end

Kino.Download.new(
  fn -> File.read!("#{__DIR__}/../../priv/outputs/bunny_with_reverted_colors.mkv") end,
  label: "Download the video",
  filename: "bunny_with_reverted_colors.mkv"
)
```

Play the output file with the command below:

```bash
$ ffplay workshop_elixir_conf_us_2024/priv/outputs/bunny_with_reverted_colors.mkv
```
